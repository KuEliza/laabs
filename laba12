"""
Вариант 7:
Вычислить сумму знакопеременного ряда |х(3n-1)|/(3n-1)!, где х-матрица ранга к (к и матрица задаются случайным образом),
n - номер слагаемого. Сумма считается вычисленной, если точность вычислений будет не меньше t знаков после запятой.
У алгоритма д.б. линейная сложность. Операция умножения –поэлементная. Знак первого слагаемого  -случайный.
"""

from random import choice, randint
import numpy as np
from decimal import Decimal, getcontext


# Вычисления суммы знакопеременного ряда
def summa(x, t):
    n = 1
    resul = 0  # результат
    factor = 2
    sign = choice([-1, 1])  # Переменная для смены знака
    matrix = x * x * x  # матрица


    # Начинаем бесконечный цикл для вычисления ряда
    while True:
        term = Decimal(np.linalg.det(matrix) / factor)  # Текущий член ряда
        resul += sign * term

        # Проверяем, достигли ли заданной точности t
        if abs(term) < 1 / (10 ** t):
            break

        # Меняем параметры для следующего слагаемого
        n += 1
        sign = -sign
        factor *= (3*n)*(3*n+1)*(3*n+2)
        matrix *= x * x

    return resul


try:
    # Ввод значения t (количества знаков после запятой)
    t = int(input('Введите число t, являющееся кол-вом знаков после запятой: '))
    while t < 1 and t > 300:
        t = int(input('Введите число t, большее или равное 1 и меньше 300:\n'))

    # Генерация случайного значения k и матрицы x
    k = randint(2, 7)
    x = np.round(np.random.uniform(-1, 1, (k, k)), 3) #создание матрицы

    print('\nСлучайно сгенерированная матрица:\n', x)

    # Установка технической точности вычислений с учетом заданной
    getcontext().prec = t + 100

    result = summa(x, t)

    # Вывод результата с заданной точностью
    print(f"\nСумма ряда с точностью {t} знаков после запятой: {result:.{t}f}".rstrip('0').rstrip('.'))

# Ошибка на случай введения не числа в качестве точности
except ValueError:
    print('\nВведите число.')

